                                  What is Thread in java

A thread is a lightweight sub process 
Threads are independent, if there occurs exception in one thread, it doesn't affect other threads. 
It shares a common memory area

--------------------------------------------------------------------------------------------------------------
Excecuting Two or more Methods in a single Java program along with main method
 is known as multi-threading


---Thread is basically a lightweight sub-process, a smallest unit of processing. 
Multiprocessing and multithreading, both are used to achieve multitasking.

But we use multithreading than multiprocessing because threads share a common memory area. 
They don't allocate separate memory area so saves memory, 
and context-switching between the threads takes less time than process.
Java Multithreading is mostly used in games, animation etc.

----------------------------------------------------
Multitasking
Multitasking is a process of executing multiple tasks simultaneously. 
We use multitasking to utilize the CPU. Multitasking can be achieved by two ways:

Process-based Multitasking(Multiprocessing)
Thread-based Multitasking(Multithreading)

1) Process-based Multitasking (Multiprocessing)

Each process have its own address in memory i.e. each process allocates separate memory area.
Process is heavyweight.
Cost of communication between the process is high.
Switching from one process to another require some time for saving and loading registers, 
memory maps, updating lists etc.

2) Thread-based Multitasking (Multithreading)
Threads share the same address space.
Thread is lightweight.
Cost of communication between the thread is low.
Note: At least one process is required for each thread.



How to create thread
There are two ways to create a thread:

---By extending Thread class
----By implementing Runnable interface.

Thread class:
Thread class provide constructors and methods to create and perform operations on a thread.
Thread class extends Object class and implements Runnable interface.
Commonly used Constructors of Thread class:
Thread()
Thread(String name)
Thread(Runnable r)
Thread(Runnable r,String name)

Commonly used methods of Thread class:
public void run(): is used to perform action for a thread.
public void start(): starts the execution of the thread.JVM calls the run() method on the thread.
public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds.
public void join(): waits for a thread to die.
public void join(long miliseconds): waits for a thread to die for the specified miliseconds.
public int getPriority(): returns the priority of the thread.
public int setPriority(int priority): changes the priority of the thread.
public String getName(): returns the name of the thread.
public void setName(String name): changes the name of the thread.
public Thread currentThread(): returns the reference of currently executing thread.
public int getId(): returns the id of the thread.
public Thread.State getState(): returns the state of the thread.
public boolean isAlive(): tests if the thread is alive.
public void yield(): causes the currently executing thread object to temporarily pause 
and allow other threads to execute.
public void suspend(): is used to suspend the thread(depricated).
public void resume(): is used to resume the suspended thread(depricated).
public void stop(): is used to stop the thread(depricated).
public boolean isDaemon(): tests if the thread is a daemon thread.
public void setDaemon(boolean b): marks the thread as daemon or user thread.
public void interrupt(): interrupts the thread.
public boolean isInterrupted(): tests if the thread has been interrupted.
public static boolean interrupted(): tests if the current thread has been interrupted.

 
Runnable interface:
The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run().
public void run(): is used to perform action for a thread.
Starting a thread:
start() method of Thread class is used to start a newly created thread. It performs following tasks:
A new thread starts(with new callstack).
The thread moves from New state to the Runnable state.
When the thread gets a chance to execute, its target run() method will run.

1) Java Thread Example by extending Thread class
class Multi extends Thread{  
public void run(){  
System.out.println("thread is running...");  
}  
public static void main(String args[]){  
Multi t1=new Multi();  
t1.start();  
 }  
}  
Output:thread is running...

2) Java Thread Example by implementing Runnable interface
class Multi3 implements Runnable{  
public void run(){  
System.out.println("thread is running...");  
}  
  
public static void main(String args[]){  
Multi3 m1=new Multi3();  
Thread t1 =new Thread(m1);  
t1.start();  
 }  
}  
Output:thread is running...

If you are not extending the Thread class,your class object would not be treated as a thread object.
So you need to explicitely create Thread class object.
We are passing the object of your class that implements Runnable so that your class run() 
method may execute. 



Life Cycle of a Thread
A thread goes through various stages in its life cycle. For example, a thread is born, started, runs, and then dies. The following diagram shows the complete life cycle of a thread.

Java Thread
Following are the stages of the life cycle -

New - A new thread begins its life cycle in the new state.
 It remains in this state until the program starts the thread. 
It is also referred to as a born thread.

Runnable - After a newly born thread is started, the thread becomes runnable.
 A thread in this state is considered to be executing its task.

Waiting - Sometimes, a thread transitions to the waiting state while the thread waits for another thread to perform a task.
 A thread transitions back to the runnable state only when another thread signals the waiting thread to continue executing.

Timed Waiting - A runnable thread can enter the timed waiting state for a specified interval of time.
 A thread in this state transitions back to the runnable state when that time interval expires or 
when the event it is waiting for occurs.

Terminated (Dead) - A runnable thread enters the terminated state when it completes its task or otherwise terminates.


Thread Scheduler in Java---------
Thread scheduler in java is the part of the JVM that decides which thread should run.

There is no guarantee that which runnable thread will be chosen to run by the thread scheduler.

Only one thread at a time can run in a single process.

The thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads.


Difference between preemptive scheduling and time slicing
Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence.
 Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks.
 The scheduler then determines which task should execute next, based on priority and other factors.
public class ThreadPriority extends Thread {

	public void run() {
		
		while(true) {
			
			System.out.println(Thread.currentThread().getName());
		}
	}
	


}

public class Threadexample {

	public static void main(String[] args) {

		ThreadPriority t = new ThreadPriority();
		
		Thread t1 = new Thread(t,"aaa");
		Thread t2 = new Thread(t, "BBB");
t1.start();
t2.start();

t1.setPriority(Thread.MIN_PRIORITY);
t2.setPriority(Thread.MAX_PRIORITY);

	}

}




                                   Sleep method in java

The sleep() method of Thread class is used to sleep a thread for the specified amount of time.

Syntax of sleep() method in java
The Thread class provides two methods for sleeping a thread:

public static void sleep(long miliseconds)throws InterruptedException
public static void sleep(long miliseconds, int nanos)throws InterruptedException
Example of sleep method in java
class TestSleepMethod1 extends Thread{  
 public void run(){  
  for(int i=1;i<5;i++){  
    try{Thread.sleep(500);}catch(InterruptedException e){System.out.println(e);}  
    System.out.println(i);  
  }  
 }  
 public static void main(String args[]){  
  TestSleepMethod1 t1=new TestSleepMethod1();  
  TestSleepMethod1 t2=new TestSleepMethod1();  
   
  t1.start();  
  t2.start();  
 }  
}  
Output:

       1
       1
       2
       2
       3
       3
       4
       4

----------------------------------------------------------------------------------------------------------



public class Test {

	public static void main(String[] args) {
		Super s = new Subclass();
		s.foo();
	}
}

class Super {
	void foo() {
		System.out.println("Super");
	}
}

class Subclass extends Super {
	static void foo() {
		System.out.println("Subclass");
	}

}

compilation error
-------------------------------------------------------------------------

public class Test {

	public void main(String[] args) {
		
		int x = 10*20-20;
		
		System.out.println(x);
	}

}